# Developing a plugin

Flhook 4.0 provides a basic template plugin which provides the overall structure of a minimumally viable plugin and involves 3 main parts. 
1. The Header, in which all configuration data will be defined in.
2. The central logic of the plugin that is the actual functionality. Any user commands will also be defined here. 
3. Hooks and Serialization, allows the plugin to be called by FlHook itself based on the defined hooks.

# Example and Overview

First lets go over the Template plugin and explain what does what.

## Header

```cpp 
#pragma once

#include <FLHook.hpp>
#include <plugin.h>

namespace Plugins::Template
{
	// Loadable json configuration
	struct Config : Reflectable
	{
		std::string File() override { return "config/template.json"; }
		bool overrideUserNumber = false;
	};

	struct Global
	{
		std::unique_ptr<Config> config = nullptr;
		ReturnCode returnCode = ReturnCode::Default;
	};
} // namespace Plugins::Template
```

Every plugin must have the struct Global, any variable that multiple functions within the plugin need should be defined here. 
Any usage of the reflectable config system should also be a member of Global as a unique_ptr as shown in this example. It should inherit from Reflectable as that allows it to be saved as and loaded from JSON. 

## Body

```cpp
#include "Main.hpp"

#include <random>

namespace Plugins::Template
{
	const auto global = std::make_unique<Global>();

	// Put things that are performed on plugin load here!
	void LoadSettings()
	{
		// Load JSON config
		auto config = Serializer::JsonToObject<Config>();
		global->config = std::make_unique<Config>(std::move(config));
	}

	// Demo command
	void UserCmdTemplate(ClientId& client, const std::wstring& param)
	{
		// Access our config value
		if (global->config->overrideUserNumber)
		{
			std::random_device dev;
			std::mt19937 rng(dev());
			std::uniform_int_distribution<std::mt19937::result_type> dist(1, 6); // distribution in range [1, 1000]

			PrintUserCmdText(client, std::format(L"The gods decided your number is actually: {}", dist(rng)));
			return;
		}

		if (const auto number = ToInt(GetParam(param, ' ', 0)); number > 0)
		{
			PrintUserCmdText(client, L"You put in the following number: " + std::to_wstring(number));
		}
		else
		{
			PrintUserCmdText(client, L"ERR: You must provide a valid positive non-zero number.");
		}
	}

	// Define usable chat commands here
	const std::vector commands = {{
	    CreateUserCommand(L"/template", L"<number>", UserCmdTemplate, L"Outputs a user provided non-zero number."),
	}};

	// Demo admin command
	void AdminCmdTemplate(CCmds* cmds, float number)
	{
		if (cmds->ArgStrToEnd(1).length() == 0)
		{
			cmds->Print("ERR Usage: template <number>");
			return;
		}

		if (!(cmds->rights & RIGHT_SUPERADMIN))
		{
			cmds->Print("ERR No permission");
			return;
		}

		cmds->Print(std::format("Template is {}", number));
		return;
	}

	// Admin command callback. Compare the chat entry to see if it match a command
	bool ExecuteCommandString(CCmds* cmds, const std::wstring& cmd)
	{
		if (cmd == L"template")
		{
			AdminCmdTemplate(cmds, cmds->ArgFloat(1));
		}
		else
		{
			return false;
		}

		global->returnCode = ReturnCode::SkipAll;
		return true;
	}

}
```

First thing will be initializing the Global, and defining the Load Settings function, then define your plugin logic. If you want to expose any sort of user functionality through chat commands you need to use the
command vector system.  --TODO: Describe Command Vectors

## Hooks

```cpp
REFL_AUTO(type(Config), field(overrideUserNumber));

DefaultDllMainSettings(LoadSettings);

extern "C" EXPORT void ExportPluginInfo(PluginInfo* pi)
{
	// Full name of your plugin
	pi->name("$projectname$");
	// Shortened name, all lower case, no spaces. Abbreviation when possible.
	pi->shortName("$safeprojectname$");
	pi->mayUnload(true);
	pi->commands(&commands);
	pi->returnCode(&global->returnCode);
	pi->versionMajor(PluginMajorVersion::VERSION_04);
	pi->versionMinor(PluginMinorVersion::VERSION_00);
	pi->emplaceHook(HookedCall::FLHook__LoadSettings, &LoadSettings, HookStep::After);
	pi->emplaceHook(HookedCall::FLHook__AdminCommand__Process, &ExecuteCommandString);
}
``` 

The last section allows the plugin to actually interface with FlServer, specifically with the pi->emplaceHook. For a detailed list on all the hooks and what they do, please see Hooks List. 
REFL_AUTO is the macro used to handle serialization of config information, any reflectable fields you define need to be placed here.

# Adding to the example

To show a basic overview of how to edit and develop plugins we'll add two simple functions, one that will print a message to the player that welcomes them to the base they just docked on if configured to do so. And another
that will tell you the clientId of a logged in character.


```cpp
namespace Plugins::Template
{
	// Loadable json configuration
	struct Config : Reflectable
	{
		std::string File() override { return "config/template.json"; }
		bool overrideUserNumber = false;

        //Add this value so admins can configure this in json. 
        bool notifyUserOnBaseEntry = true;
	};

	struct Global
	{
		std::unique_ptr<Config> config = nullptr;
		ReturnCode returnCode = ReturnCode::Default;
	};
} // namespace Plugins::Template
```


Now lets create the function that welcomes the player to the base. 

```cpp
void WelcomePlayerToBase(ClientId& client)
{
     // HK functions return a result type which a variant of the type you want ,in this case the base of the current clientId, or an error type if something went wrong.
    // The error will also return a type of error that will give more specific information.
    const auto playerBaseId = Hk::Player::GetCurrentBase(client);
    const auto playerName = Hk::Client::GetCharacterNameByID(client);

    //Error checking, we can print the error to console, log it, or print it to the user, in this case we will simply print the error to the user. 
    if (playerBaseId.has_error())
    {
         PrintUserCmdText(client, Hk::Err::ErrGetText(playerBaseId.error()));
		return;
    }

    //It often makes it nicer to extract the value from the result type rather than trying to use it, but its situation dependent. 
    // Then need to grab the actual base name as FL stores names internally by a 32 bit uint or an internal nickname 
    Universe::IBase* baseinfo = Universe::get_base(result.value());
    const auto baseName = Hk::Message::GetWStringFromIdS(baseinfo->baseIdS);

    //We have the information we need, now lets print it to the player.
    PrintUserCmdText(client, std::format(L"Hello {}, weclome to {}", playerName.value(), baseName));
}
``` 

Now we need to make this function be called whenever a player enters a base.

```cpp
extern "C" EXPORT void ExportPluginInfo(PluginInfo* pi)
{
	// Full name of your plugin
	pi->name("$projectname$");
	// Shortened name, all lower case, no spaces. Abbreviation when possible.
	pi->shortName("$safeprojectname$");
	pi->mayUnload(true);
	pi->commands(&commands);
	pi->returnCode(&global->returnCode);
	pi->versionMajor(PluginMajorVersion::VERSION_04);
	pi->versionMinor(PluginMinorVersion::VERSION_00);
	pi->emplaceHook(HookedCall::FLHook__LoadSettings, &LoadSettings, HookStep::After);
	pi->emplaceHook(HookedCall::FLHook__AdminCommand__Process, &ExecuteCommandString);

    //here we emplace the "on base load hook to do that
    pi->emplaceHook(HookedCall::IServerImpl__BaseEnter, &WelcomePlayerToBase);
}
``` 
There, now a player will be welcomed to a base every time they dock on it.

## User Commands

Now lets implement the printing of the clientId of another player, for this we need to handle user input.

```cpp

	void UserCmdTemplate(ClientId& client, const std::wstring& param)
	{
        // With plugins that have a multitude of commands, we will typically use a bunch of if-elses, but for here a simple if check before the number stuff will do,
        // in GetParam(), the first argument is the parameter, what the user inputed , in this case it will be the string after /template, so if they put in /template 'blah blah' , param will be 'blah blah'.
        // the sceond argument is how its splitting it, in this case its looking for a space and splitting the string into an array from each space and indexed
        // so with theargument of /template foo bar, index 0 is foo and index 1 is bar, of which the 3rd argument is the index of this split array you want to extract.
        if (const auto subCommand = GetParam(param, ' ', 0); subCommand == L"getId" )
        {
           const auto playerName = GetParam(param, ' ', 1);
           const auto result = Hk::Client::GetClientIdFromCharName(playerName);
           return;
        }

		// Access our config value
		if (global->config->overrideUserNumber)
		{
			std::random_device dev;
			std::mt19937 rng(dev());
			std::uniform_int_distribution<std::mt19937::result_type> dist(1, 6); // distribution in range [1, 1000]

			PrintUserCmdText(client, std::format(L"The gods decided your number is actually: {}", dist(rng)));
			return;
		}
		if (const auto number = ToInt(GetParam(param, ' ', 0)); number > 0)
		{
			PrintUserCmdText(client, L"You put in the following number: " + std::to_wstring(number));
		}
        
		else
		{
			PrintUserCmdText(client, L"ERR: You must provide a valid positive non-zero number.");
		}
	}
    ``` 
    There now players can get the client Id of another player by typing '/template getId <Character Name> 